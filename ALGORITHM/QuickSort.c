#include "common.h"

int Partition(int*a, int p, int r);
void QuickSort(int* a, int p, int r);


/************************************************************************/
//分区将数组分为两部分并返回中间的坐标
//实现方式是设置两个坐标记录点分别为小端末尾点i和接受检测点也即大端末尾+1点j，
//从起始位置开始当受测点有小于标准值a[r]时，小端末尾点i即+1，将检测点a[j]与a[i]交换，
//这样实际上是大端扩充范围，大端的末尾点小于标准值a[r]于是大端首位交换，小端的末尾后移，小端扩充，
//于是得到希望的效果，--前面是小端，后面是大端。
//到结束时将标准值(数组末尾)与小端尾后，大端头交换。
//于是将数组区分成功。
/************************************************************************/
int Partition(int*a, int p, int r)
{
	int i=p-1;
	int x = a[r];
	int j;
	int flag = 1;
	for(j=p; j<r;j++)
	{
		if(a[j] < x || (a[j] == x && flag))
		{
			i++;
			printf("%d<-->%d\n",a[i],a[j]);
			Swap(&a[i],&a[j]);
			Debug(a,10,0);
			if(a[j] != x)
			{
				flag = 0;
			}
		}
	}
	printf("%d<-+->%d\n",a[i+1],a[r]);
	Swap(&a[i+1],&a[r]);
	Debug(a,10,0);
	return i+1;
}

/************************************************************************/
/*	快排
//		1、将数组分为两部分，大于a[r]的部分和小于a[r]的部分
//		2、将这两部分再次分别进行快排。
/************************************************************************/
void QuickSort(int* a, int p, int r)
{
	int q;
	if(p<r)
	{
		q = Partition(a,p,r);
		QuickSort(a,p,q-1);
		QuickSort(a,q+1,r);
	}
}

